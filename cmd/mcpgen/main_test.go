// Copyright 2025 The Go MCP SDK Authors. All rights reserved.
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.

package main

import (
"os"
"os/exec"
"path/filepath"
"strings"
"testing"
)

func TestGenerator(t *testing.T) {
	// Create a temporary directory with test types
	tmpDir, err := os.MkdirTemp("", "mcpgen-test")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tmpDir)

	// Write test input file
	inputFile := filepath.Join(tmpDir, "types.go")
	input := "package testpkg\n\n" +
		"type CreateIssueInput struct {\n" +
		"\tTitle string `json:\"title\" jsonschema:\"required,description=Issue title\"`\n" +
		"\tBody  string `json:\"body\" jsonschema:\"description=Issue body\"`\n" +
		"\tLabels []string `json:\"labels\"`\n" +
		"}\n\n" +
		"type UpdateIssueInput struct {\n" +
		"\tID    int    `json:\"id\" jsonschema:\"required\"`\n" +
		"\tTitle string `json:\"title\"`\n" +
		"\tState string `json:\"state\" jsonschema:\"enum=open|closed\"`\n" +
		"}\n"

	if err := os.WriteFile(inputFile, []byte(input), 0644); err != nil {
		t.Fatal(err)
	}

	// Write go.mod
	goMod := "module testpkg\n\ngo 1.24\n\nrequire github.com/google/jsonschema-go v0.3.0\n"
	if err := os.WriteFile(filepath.Join(tmpDir, "go.mod"), []byte(goMod), 0644); err != nil {
		t.Fatal(err)
	}

	// Run go mod tidy
	cmd := exec.Command("go", "mod", "tidy")
	cmd.Dir = tmpDir
	if out, err := cmd.CombinedOutput(); err != nil {
		t.Fatalf("go mod tidy failed: %v\n%s", err, out)
	}

	// Explicitly get the jsonschema dependency
	getCmd := exec.Command("go", "get", "github.com/google/jsonschema-go/jsonschema")
	getCmd.Dir = tmpDir
	if out, err := getCmd.CombinedOutput(); err != nil {
		t.Fatalf("go get failed: %v\n%s", err, out)
	}

	// Build the generator
	genPath := filepath.Join(t.TempDir(), "mcpgen")
	buildCmd := exec.Command("go", "build", "-o", genPath, ".")
	if out, err := buildCmd.CombinedOutput(); err != nil {
		t.Fatalf("building generator: %v\n%s", err, out)
	}

	// Run the generator
	outputFile := filepath.Join(tmpDir, "testpkg_mcp_gen.go")
	genCmd := exec.Command(genPath, "-type=CreateIssueInput,UpdateIssueInput", "-output="+outputFile)
	genCmd.Dir = tmpDir
	if out, err := genCmd.CombinedOutput(); err != nil {
		t.Fatalf("running generator: %v\n%s", err, out)
	}

	// Read the generated file
	generated, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatal(err)
	}

	// Verify the generated code contains expected elements
	content := string(generated)

	checks := []string{
		"Code generated by mcpgen",
		"package testpkg",
		"_createissueinputSchema",
		"_updateissueinputSchema",
		"MCPSchema()",
		"MCPResolvedSchema()",
		"\"title\"",
		"\"body\"",
		"jsonschema.Schema",
	}

	for _, check := range checks {
		if !strings.Contains(content, check) {
			t.Errorf("generated code missing %q", check)
		}
	}

	// Verify the generated code compiles
	verifyCmd := exec.Command("go", "build", ".")
	verifyCmd.Dir = tmpDir
	if out, err := verifyCmd.CombinedOutput(); err != nil {
		t.Errorf("generated code does not compile: %v\n%s\n\nGenerated:\n%s", err, out, content)
	}
}

func TestGeneratorNoTypes(t *testing.T) {
	cmd := exec.Command("go", "run", ".", "-type=")
	out, err := cmd.CombinedOutput()
	if err == nil {
		t.Error("expected error for empty type list")
	}
	if !strings.Contains(string(out), "no types specified") {
		t.Errorf("unexpected error message: %s", out)
	}
}
